{
  "articles": [
    {
      "path": "about.html",
      "title": "About this site",
      "description": "Some additional details about the website",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-16T15:56:39-07:00"
    },
    {
      "path": "functions.html",
      "title": "Functions",
      "description": "Repeating things? Let's functionalize it!\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nWhat’s in a function?\r\nLet’s create one\r\nCall the function\r\n\r\nBenefits of creating functions\r\n\r\nWhen we see code being repeated more than once, functions are a great way to reduce duplication. Even if we call a function only once, they can be a nice way to break up large complicated processes.\r\nWhat’s in a function?\r\nThe Formals\r\nThe Body\r\nThe Environment\r\nTo define a function here’s the basic skeleton\r\n\r\n\r\nmy_function_name <- function() {\r\n  \r\n}\r\n\r\n\r\nLet’s create one\r\nSuppose we’d like to do some cleaning to each CHAS table in the same manner. Let’s create one that does the following:\r\nfilter for PSRC counties\r\npivot longer (so columns that start with ‘T’ are not across the table)\r\ndissect the column containing the former ‘T…’ hearders into three columns\r\ncreate ‘table’ field\r\ncreate a ‘type’ field to identify whether values are ‘est’ or ‘moe’\r\ncreate a ‘sort’ field\r\n\r\n\r\n\r\n# Read-in one file as a data frame\r\nfile_01 <- read_csv(here('data', '050', 'Table9.csv'))\r\n\r\n# define the skeleton of our function\r\n# add table as a parameter\r\nclean_table <- function(table) {\r\n  \r\n}\r\n\r\n\r\nFill in the body with the argument to clean\r\n\r\n\r\nclean_table <- function(table) {\r\n  table %>% \r\n    filter(st == 53 & cnty %in% c('033', '035', '053', '061')) %>% \r\n    pivot_longer(cols = str_subset(colnames(table), \"^T.*\"), \r\n                 names_to = 'header', \r\n                 values_to = 'value') %>% \r\n    mutate(table = str_extract(header, \"^T\\\\d*(?=_)\"),\r\n           type = str_extract(header, \"(?<=_)\\\\w{3}\"),\r\n           sort = str_extract(header, \"\\\\d+$\"))\r\n}\r\n\r\n\r\n\r\nFunctions will generally return the last evaluated expression. With the piping (%>%) in dplyr, our example is essentially a one liner expression. You can always add return(<name of object>) to explicitly return a specific object whenever your function is called.\r\nCall the function\r\n\r\n\r\nt9 <- clean_table(file_01)\r\n\r\n\r\nTry with other files\r\n\r\n\r\nfile_02 <- read_csv(here('data', '050', 'Table10.csv'))\r\nfile_03 <- read_csv(here('data', '050', 'Table11.csv'))\r\n\r\nt10 <- clean_table(file_02)\r\nt11 <- clean_table(file_03)\r\n\r\n\r\nIf we forgot a step in the cleaning process, we can always edit the function and re-run our script\r\n\r\n\r\n# Let's make this edit to our function that will convert the sort column from string to numeric\r\nsort = as.numeric(str_extract(header, \"\\\\d+$\"))\r\n\r\n\r\nBenefits of creating functions\r\nEasier editing of code\r\nReduce redundancy\r\nBreak long processes into chunks\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-16T15:56:43-07:00"
    },
    {
      "path": "index.html",
      "title": "Code Organization",
      "description": "Functions, Lists, and Loops\n",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-16T15:56:44-07:00"
    },
    {
      "path": "lists.html",
      "title": "Lists",
      "description": "Lists are our friend!\n",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-16T15:56:44-07:00"
    }
  ],
  "collections": []
}
