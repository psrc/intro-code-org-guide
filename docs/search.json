{
  "articles": [
    {
      "path": "about.html",
      "title": "About this site",
      "description": "Some additional details about the website",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-23T14:44:42-07:00"
    },
    {
      "path": "functions.html",
      "title": "Functions",
      "description": "Repeating things? Let's functionalize it!\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nWhat’s in a function?\r\nLet’s create one\r\nCall the function\r\n\r\nBenefits of creating functions\r\n\r\nWhen we see code being repeated more than once, functions are a great way to reduce duplication. Even if we call a function only once, they can be a nice way to break up large complicated processes.\r\nWhat’s in a function?\r\nThe Formals\r\nThe Body\r\nThe Environment\r\nTo define a function here’s the basic skeleton\r\n\r\n\r\nmy_function_name <- function() {\r\n  \r\n}\r\n\r\n\r\nLet’s create one\r\nSuppose we’d like to do some cleaning to each CHAS table in the same manner. Let’s create one that does the following:\r\nfilter for PSRC counties\r\npivot longer (so columns that start with ‘T’ are not across the table)\r\ndissect the column containing the former ‘T…’ headers into three columns\r\ncreate ‘table’ field\r\ncreate a ‘type’ field to identify whether values are ‘est’ or ‘moe’\r\ncreate a ‘sort’ field\r\n\r\n\r\n\r\n# Read-in one file as a data frame\r\nfile_01 <- read_csv(here('data', '050', 'Table9.csv'))\r\n\r\n# define the skeleton of our function\r\n# add table as a parameter\r\nclean_table <- function(table) {\r\n  \r\n}\r\n\r\n\r\nFill in the body with the argument to clean\r\n\r\n\r\nclean_table <- function(table) {\r\n  table %>% \r\n    filter(st == 53 & cnty %in% c('033', '035', '053', '061')) %>% \r\n    pivot_longer(cols = str_subset(colnames(table), \"^T.*\"), \r\n                 names_to = 'header', \r\n                 values_to = 'value') %>% \r\n    mutate(table = str_extract(header, \"^T\\\\d*(?=_)\"), # string starting with T and numeric digits followed by _\r\n           type = str_extract(header, \"(?<=_)\\\\w{3}\"), # 3 letters preceded by _\r\n           sort = str_extract(header, \"\\\\d+$\")) # last numeric digits at the end of the string\r\n}\r\n\r\n\r\n\r\nFunctions will generally return the last evaluated expression. With the piping (%>%) in dplyr, our example is essentially a one liner expression. You can always add return(<name of object>) to explicitly return a specific object whenever your function is called.\r\nCall the function\r\n\r\n\r\nt9 <- clean_table(file_01)\r\n\r\n\r\nTry with other files\r\n\r\n\r\nfile_02 <- read_csv(here('data', '050', 'Table10.csv'))\r\nfile_03 <- read_csv(here('data', '050', 'Table11.csv'))\r\n\r\nt10 <- clean_table(file_02)\r\nt11 <- clean_table(file_03)\r\n\r\n\r\nIf we forgot a step in the cleaning process, we can always edit the function and re-run our script\r\n\r\n\r\n# Let's make this edit to our function that will convert the sort column from string to numeric\r\nsort = as.numeric(str_extract(header, \"\\\\d+$\"))\r\n\r\n\r\nBenefits of creating functions\r\nEasier editing of code\r\nReduce redundancy\r\nBreak long processes into chunks\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-23T14:44:47-07:00"
    },
    {
      "path": "index.html",
      "title": "Code Organization",
      "description": "Functions, Lists, and Loops\n",
      "author": [],
      "contents": "\r\nIt’s never too late to start organizing code! It’s a step towards cleaner scripts which not only benefit the machines that execute it but the humans who are reading and understanding the logic. We’ll go over three essentials of programming (in R) that can help us remove redundant code and efficiently process and store multiple objects. With these tools: Functions, lists, and loops, your scripts can become more concise and readable.\r\n\r\n\r\n\r\n\r\n\r\nShortcut Keys\r\nf: full-screen\r\nEsc: exit full-screen\r\no: tile view\r\nleft or right arrow: advance slide\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-23T14:44:48-07:00"
    },
    {
      "path": "lists.html",
      "title": "Lists",
      "description": "Lists are our friend!\n",
      "author": [],
      "contents": "\r\nLists can not only store a mix of data types, but also more complex data (e.g. data frames, even lists themselves!). It’s an ideal option for a group of similar complex data, and decently sets us up for iteration! So in preparation for for loops, let’s examine lists and how to extract data from them.\r\nCreate a list\r\n\r\n\r\n# an empty list\r\nl <- list() \r\n\r\n# populated with objects\r\nl <- list(file_01, file_02, file_03) \r\n\r\n\r\nAnatomy\r\nThere’s several layers to a list, like a container within a container. To extract a specific element’s data, use double brackets instead one.\r\n\r\n\r\nl # the whole list and all its elements\r\n\r\nl[1] # the first element in its container; contains the name/index of element and the data\r\n\r\nl[[1]] # the data of the first element\r\n\r\n\r\nHadley Wickham’s pepper analogy\r\n\r\nNames\r\nLike vectors, lists can also be named\r\n\r\n\r\nnames(l) <- c('table9', 'table10', 'table11')\r\n\r\n\r\nNow you can also access the data of a specific element by name using $ or [[]]\r\n\r\n\r\nl$table9\r\n\r\nl[['table9']]\r\n\r\n# saving processes back into the list\r\nl$table9 <- l$table9 %>% filter(cnty == '033')\r\n\r\n\r\nNow if you extract an element with only one [] like l[1], you can see that it’s a container holding the name of the element and the data itself.\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-23T14:44:49-07:00"
    },
    {
      "path": "loops.html",
      "title": "Loops",
      "description": "Over and Over again...\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nAnatomy\r\nSequence\r\nOutput\r\n\r\nPut it all together\r\nSequencing alternatives\r\n\r\nAlter the Flow\r\nBreak\r\nNext\r\n\r\n\r\nWe could explicitly call the function as many times need be to clean the tables we’re interested in.\r\n\r\n\r\ntable9 <- clean_table(file_01)\r\n\r\ntable10 <- clean_table(file_02)\r\n\r\ntable11 <- clean_table(file_03)\r\n\r\n\r\nBut that would be redundant! Imagine if we were reading in 15 of those csvs! There would be extra lines of code and as many extra variable names in your global environment to keep track of. Let’s see how loops paired with lists can help us!\r\nAnatomy\r\nA for loop has three parts:\r\nThe Output: where the stuff will be stored\r\nThe Sequence: code within () that shows what to loop over\r\nThe Body: code within {} that does the work\r\nSequence\r\nThe sequence lies within the (). It will follow this structure:\r\n([variable name of your choice] in [list or vector])\r\nThe sequence tells the machine what to loop over. The variable name of your choice will represent a single element within the list or vector in a loop.\r\nIn the example below, with every iteration, df will be a counter and represent a different data frame in l\r\n\r\n\r\nl <- list(file_01, file_02, file_03)\r\n\r\n# for every data frame (df) in list (l)...\r\nfor(df in l) {\r\n  \r\n}\r\n\r\n\r\nTry printing the head() of each data frame in our list\r\n\r\n\r\nl <- list(file_01, file_02, file_03) \r\n\r\nfor(df in l) {\r\n  print(head(df))\r\n}\r\n\r\n\r\nTry printing a version of each data frame with clean_table()\r\n\r\n\r\nfor(df in l) {\r\n  print(clean_table(df))\r\n}\r\n\r\n\r\nOutput\r\nNow instead of printing stuff, let’s store stuff in a list!\r\nA way to use both lists and loops is to read data. Let’s create a loop to read-in csvs 1 through 11 and store them into a list.\r\nInitiate the Output (dfs) to store the end result (data frames from csvs)\r\nConstruct the sequence you’ll be looping over (csv) (file names of csvs)\r\nRead csv (t)\r\n\r\n\r\ndfs <- list()\r\n\r\ncsv <- paste0('Table', 1:11, '.csv')\r\n\r\nfor(c in csv) {\r\n  t <- read_csv(here('data', '050', c))\r\n  dfs[[c]] <- t\r\n}\r\n\r\n\r\nRename the elements in the list\r\n\r\n\r\nnames(dfs) <- paste0('Table', 1:11)\r\n\r\n\r\nPut it all together\r\nEdit the loop so that we clean the tables as we’re reading in the csvs.\r\n\r\n\r\nfor(c in csv) {\r\n  t <- read_csv(here('data', '050', c))\r\n  ct <- clean_table(t)\r\n  dfs[[c]] <- ct\r\n}\r\n\r\n\r\nWith loops and a list to store the output, we’ve removed code redundancy. Instead of calling clean_table() for every table in our list, it just required editing a couple lines within the loop to make that adjustment.\r\nSequencing alternatives\r\n\r\n\r\nfor(df in 1:length(l)) {\r\n  \r\n}\r\n\r\n\r\nAlter the Flow\r\nBreak\r\nNext\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-23T14:44:50-07:00"
    }
  ],
  "collections": []
}
